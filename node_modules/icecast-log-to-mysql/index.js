module.exports = IcecastToMySQL;

var moment = require('moment'),
    mkdirp = require('mkdirp'),
    config = require('config'),
     async = require('async'),
     mysql = require('mysql'),
      path = require('path'),
        fs = require('fs'), log;

var db = config.get('db');
var parser = config.get('parser');
var geoConfig = config.get('geo');
var mounts_filter = config.get('mounts_filter');

var sypex = require('sypexgeo-vyvid');
var sypexGeoDb = new sypex.Geo(geoConfig.sypex_path);
var maxmind = require('maxmind');

var FTPClient = require('ftp');

require('moment-range');

function IcecastToMySQL(options) {
    this.logName = options.name;

    switch (this.logName) {
        case 'access.log':
            this.pattern = 'access*';
            this.tracerFile = parser.log_file_access;
            break;
        case 'playlist.log':
            this.pattern = "playlist*";
            this.tracerFile = parser.log_file_playlist;
            break;
        default:
            throw new Error("Please specify icecast log name for parsing");
    }

    // for catching native code crashes
    var SegfaultHandler = require('segfault-handler');
    SegfaultHandler.registerHandler(getLogFileNameWithDate(parser.log_file_crash));

    this.error_messages = [];

    var tracer = require('tracer');
    if (parser.log_to_file)
        log = tracer.console(this.getLogConfig(this.tracerFile));
    else
        log = tracer.colorConsole(getConsoleLogConfig());

    this.targetDate = options.date;
    this.logDiffDays = options.logDiffDays;
    this.skip_insert = options.skip_insert;
    this.retryTimesOnFail = options.retryTimesOnFail;
    this.retryIntervalOnFail = options.retryIntervalOnFail;
    this.filterByHost = options.filterByHost;

    maxmind.init(geoConfig.geo_city_path);
}

function getConsoleLogConfig() {
    return {
        format : [
            "{{timestamp}}\t({{file}}:{{line}})\t<{{title}}>\t{{message}} ",
            {
                error : "{{timestamp}}\t({{file}}:{{line}})\t<{{title}}>\t{{message}}\nCall Stack:\n{{stack}}",
            }
        ],
        dateformat : "yyyy-mm-dd HH:MM:ss.L",
        level: parser.level,
        transport : function(data) {
            console.log(data.output);
        }
    };
}

function getLogFileNameWithDate(log_file) {
    var extension = moment().format("YYYY_MM_DD__HH_mm_ss");
    return log_file + "_" + extension;
}

 IcecastToMySQL.prototype.getLogConfig = function(log_file) {
    if (!fs.existsSync("logs"))
        fs.mkdirSync("logs");

    log_file = getLogFileNameWithDate(log_file);

    var self = this;

    return {
        format : [
            "{{timestamp}}\t({{file}}:{{line}})\t<{{title}}>\t{{message}} ",
            {
                error : "{{timestamp}} <{{title}}> {{message}} ({{file}}:{{line}})\nCall Stack:\n{{stack}}"
            }
        ],
        dateformat : "yyyy-mm-dd HH:MM:ss.L",
        level: parser.level,
        transport : function(data) {
            console.log(data.output);

            if (data.title === 'error')
                self.error_messages.push(data.timestamp + " " + data.message + " (" + data.file + ": " + data.line + ")");

            if (!self.log_stream) {
                self.log_stream = fs.createWriteStream(log_file, {
                    flags: "a",
                    encoding: "utf8",
                    mode: 0666
                });
            }
            self.log_stream.write(data.output+"\n");
        }
    };
};

IcecastToMySQL.prototype.isDateYesterday = function(date) {
    var yesterday = moment().subtract(1, 'day');
    return (moment(date).isSame(yesterday, 'day'));
};

IcecastToMySQL.prototype.read_ftp_configs_from_sql_table = function(callback) {
    log.info("Read configuration from database");

    var self = this;

    var con = mysql.createConnection({
        host: db.host,
        user: db.user,
        password: db.password,
        connectTimeout: db.timeout * 1000
    });

    async.waterfall([
        function(cb) {
            con.connect(function(err, res){
                cb(err, res);
            });
        },
        function(rows, cb) {
            con.query('use `' + db.admin_db + '`', function(err, rows){ cb(err, rows); });
        },
        function(rows, cb) {
            con.query('select id, ftp_host as host, ftp_username as user, ftp_password as pass from `' + db.stations_table + '` where update_db = 1', function(err, rows){ cb(err, filterByFtpHostname(self, rows)); });
        }
    ], function (err, rows) {
        log.info("ftp list count: " + rows.length);
        callback(err, rows);
        con.end(function(err) {
            if (err) {
                log.error(err.message);
            }
        });
    });
};

function filterByFtpHostname(self, ftpList) {
    if (self.filterByHost) {
        var result = [];
        for (var i = 0; i < ftpList.length; i++) {
            if (ftpList[i].host.indexOf(self.filterByHost) != -1)
                result.push(ftpList[i]);
        }
        return result;
    }
    return ftpList;
}

var retryGetRemoteListCount = 0;
IcecastToMySQL.prototype.get_remote_log_files_list = function(ftp, callback) {
    var self = this;
    retryGetRemoteListCount = 0;
    async.retry({times: self.retryTimesOnFail, interval: self.retryIntervalOnFail}, get_ftp_file_list.bind({self: self, ftp: ftp}), function(err, list) {
        if (err)
            writeToFileListThatNeedToRedownload(self.logName, ftp, "get_list", err);
        callback(null, list);
    });
};

function get_ftp_file_list(callback) {
    retryGetRemoteListCount++;
    var self = this.self;
    var ftp = this.ftp;
    normalizeFtpHostAndLogPath(ftp);

    ftp.client = new FTPClient();

    // timeout if no success to list remote directory
    var timerId = setTimeout(function() {
        var err = new Error('(' + ftp.id + '_' + ftp.host + ') : Timed Out!');
        log.error(err);
        if (ftp.client) {
            ftp.client.end();
            ftp.client = null;
        }
        if (!isCallbackCalled) {
            callback(err, []);
            isCallbackCalled = true;
        }
    }, 60000);

    var isCallbackCalled = false;
    ftp.client.on('ready', function() {
        log.debug('(ftp '+ ftp.id +') connected to: ' + ftp.host + ' try #' + retryGetRemoteListCount);
        var remotePath = (ftp.log_path ? path.join(ftp.log_path, self.pattern) : self.pattern);
        ftp.client.list(remotePath, function(err, list) {
            log.debug('(ftp ' + ftp.id + ') list from: ' + ftp.host);
            if (err) {
                if (!isCallbackCalled) {
                    callback(err, []);
                    isCallbackCalled = true;
                }
            } else {
                var exList = sortAndExtractFilesByDate(self, ftp, list);
                ftp.client.end();
                ftp.client = null;
                if (!isCallbackCalled) {
                    callback(null, exList);
                    isCallbackCalled = true;
                }
            }
            if (timerId)
                clearTimeout(timerId);
        });
    });

    ftp.client.on('error', function(err) {
        log.warn("ftp: " + ftp.host + " error: " + err.message);
        if (!isCallbackCalled) {
            callback(err, []);
            isCallbackCalled = true;
        }
        if (timerId)
            clearTimeout(timerId);
    });

    ftp.client.connect({host:ftp.host, user:ftp.user, password:ftp.pass, keepalive: 5000, connTimeout: 30000, pasvTimeout:30000});
}

function normalizeFtpHostAndLogPath(ftp) {
    if (ftp.host.indexOf("/") > 0) {
        var sarr = ftp.host.split("/");
        ftp.host = sarr[0];
        ftp.log_path = sarr[1];
    } else {
        ftp.host = ftp.host;
        ftp.log_path = '';
    }
}

function sortAndExtractFilesByDate(self, ftp, list) {
    // sort dates by desc
    if (list.length > 1) {
        list.sort(function(a,b) {
            a.date = getDateFromLogFileName(a.name);
            b.date = getDateFromLogFileName(b.name);
            return b.date.milliseconds() - a.date.milliseconds();
        });
    } else {
        if (list.length == 1) {
            list[0].date = getDateFromLogFileName(list[0].name);
        }
    }

    var start_date = moment(self.targetDate).subtract(self.logDiffDays, 'day').startOf('day');
    var end_date = moment(self.targetDate).add(self.logDiffDays, 'day').endOf('day');
    var range_date = moment.range(start_date, end_date);

    var result = [];
    for (var i = 0; i < list.length; i++) {
        var fsItem = list[i];
        if (range_date.contains(fsItem.date)) {
            result.push(fsItem);
        }
    }

    log.debug("------> " + ftp.host);
    for (var k = 0; k < result.length; k++) {
        log.debug(result[k].name + " -> " + Math.round(result[k].size / 1024 / 1024) + " (Mb)" + " -> " + result[k].size);
    }

    return result;
}

function getDateFromLogFileName(name) {
    if (name.indexOf("_") > 0) {
        var s_index = name.lastIndexOf(".") + 1;
        var e_index = name.lastIndexOf("_");
        return moment(name.substring(s_index, e_index), 'YYYYMMDD');
    }
    return moment();
}

var redownloadCount = 0;
IcecastToMySQL.prototype.redownload_log_files = function(ftp, remoteFileList, callback) {
    var self = this;
    var dest = path.join("downloads", ftp.id + "_" + ftp.host);
    mkdirp(dest, function(err){
        if (err) {
            callback(err, null);
        } else {
            redownloadCount = 0;
            var opts = {ftp: ftp, remoteFileList: remoteFileList, dest: dest};
            async.retry({times: self.retryTimesOnFail, interval: self.retryIntervalOnFail}, redownload_list.bind(opts), function(err, results) {
                if (err)
                    writeToFileListThatNeedToRedownload(self.logName, ftp, 'redownload_log_files', err);
                callback(null, results);
            });
        }
    });
};

function redownload_list(callback) {
    redownloadCount++;
    log.debug("Try to redownload " + this.remoteFileList.length + " files");
    var ftp = this.ftp;
    download_list(this.ftp, this.remoteFileList, this.dest, function(err, results) {
        var failedList = [];
        var successList = [];
        for (var i = 0; i < results.length; i++) {
            var result = results[i];
            if (result.error) {
                failedList.push(result.remoteFile);
            } else {
                successList.push(result);
                log.info("File " + result.path + " was redownloaded success when try #" + redownloadCount);
            }
        }
        if (failedList.length > 0) {
            var msg = "";
            for (var j = 0; j < failedList.length; j++)
                msg += failedList[j].name + ", ";
            callback(new Error('Trying ('+redownloadCount+'). Not all files was redownloaded (' + ftp.host + ')! They are: ' + msg), null);
        } else {
            callback(err, results);
        }
    });
}

function writeToFileListThatNeedToRedownload(logName, ftp, methodName, err) {
    log.error("Failed to download from " + ftp.host + " Error: " + err.message + " Method: " + methodName);
    var timestr = moment().format("YYYY_MM_DD");
    fs.appendFile(path.join('logs', 'need_to_redownload_' + timestr + logName), ftp.host +
                  " Method: " + methodName +
                  " Error: " + (err.message ? err.message : '') + '\n', function (err) {
        if (err) log.error(err);
    });
}

var retryDownloadLogsCount = 0;
IcecastToMySQL.prototype.download_log_files = function(ftp, remoteFileList, callback) {
    var dest = path.join("downloads", ftp.id + "_" + ftp.host);
    mkdirp(dest, function(err){
        if (err) {
            callback(err, null);
        } else {
            var self = this;
            retryDownloadLogsCount = 0;
            async.retry({times: self.retryTimesOnFail, interval: self.retryIntervalOnFail}, try_download_list.bind({ftp: ftp, remoteFileList: remoteFileList, dest: dest}), function(err, logs) {
                if (err)
                    writeToFileListThatNeedToRedownload(self.logName, ftp, "download_logs", err);
                callback(null, logs);
            });
        }
    });
};

function try_download_list(callback) {
    var ftp = this.ftp;
    var remoteFileList = this.remoteFileList;
    var dest = this.dest;
    retryDownloadLogsCount++;
    log.info(ftp.host + ": trying download log files by #" + retryDownloadLogsCount);
    download_list(ftp, remoteFileList, dest, callback);
}

function download_list(ftp, remoteFileList, dest, callback) {
    ftp.client = new FTPClient();

    var isCallbackCalled = false;

    // timeout if no success to list remote directory
    var timerId = setTimeout(function() {
        var err = new Error('(' + ftp.id + '_' + ftp.host + ') : Timed Out when download files!');
        log.error(err);
        if (ftp.client) {
            ftp.client.end();
            ftp.client = null;
        }
        if (!isCallbackCalled) {
            callback(err, []);
            isCallbackCalled = true;
        }
    }, 60 * 60000); // give one hour to download all needed files by single ftp

    ftp.client.on('error', function(err) {
        log.warn("ftp: " + ftp.host + " error: " + err.message);
        if (!isCallbackCalled) {
            callback(err, []);
            isCallbackCalled = true;
        }
        if (timerId)
            clearTimeout(timerId);
    });

    ftp.client.on('ready', function() {
        log.debug('(ftp '+ ftp.id +') connected to: ' + ftp.host + ' start download files!');
        async.map(remoteFileList, download_remote_file.bind({ftp: ftp, dest: dest}), function(err, results) {
            log.info("(ftp download) close connection: " + ftp.host);
            if (ftp.client) {
                ftp.client.end();
                ftp.client = null;
            }
            if (err) {
                if (!isCallbackCalled) {
                    callback(err, results);
                    isCallbackCalled = true;
                }
            } else {
                if (!isCallbackCalled) {
                    callback(null, results);
                    isCallbackCalled = true;
                }
            }
            if (timerId)
                clearTimeout(timerId);
        });
    });

    ftp.client.connect({host:ftp.host, user:ftp.user, password:ftp.pass, keepalive: 5000, connTimeout: 30000, pasvTimeout:30000});
}

function download_remote_file(remoteFile, callback) {
    var ftp = this.ftp;
    var dest = this.dest;

    if (remoteFile.name.lastIndexOf('/') != -1)
        remoteFile.name = remoteFile.name.substring(remoteFile.name.lastIndexOf('/'), remoteFile.name.length);

    var destFilePath = path.join(dest, remoteFile.name);
    remoteFile.path = ftp.log_path ? path.join(ftp.log_path, remoteFile.name) : remoteFile.name;

    log.debug('(ftp download) get: ' + ftp.host + " -> " + remoteFile.path + " dest -> " + destFilePath);

    var result = {};
    ftp.client.get(remoteFile.path, function(err, stream) {
        // TODO: С callback магия какая-та, почему-то, когда err разработчик не делает вызов callaback
        if (err) {
            result.error = err;
        } else if (!stream) { // Бывает, что stream –– undefined. Ошибка вида: Cannot read property 'once' of undefined
            result.error = err;
            console.error('func download_remote_file: ERROR - stream not exist => ', err);
            callback(null, result);
        } else {
            stream.once('close', function() {
                log.debug("(ftp download finished): " + ftp.host +
                    " File name: " + remoteFile.name +
                    " Remote file size: " + remoteFile.size +
                    " Local read size: " + stream.bytesRead);

//              if (remoteFile.size != stream.bytesRead)
//                  throw new Error("Files are not identical by size!!! Remote: " + remoteFile.size + " Local: " + stream.bytesRead);

                result.path = destFilePath;
                result.remoteFile = remoteFile;
                callback(null, result);
            });
            removeFileIfExist(destFilePath);
            stream.pipe(fs.createWriteStream(destFilePath));
        }
    });
}

function removeFileIfExist(filePath) {
    if (fs.existsSync(filePath))
        fs.unlinkSync(filePath);
}

IcecastToMySQL.prototype.parse_log_files = function(ftp, fileList, callback) {
    var self = this;
    async.map(fileList, parse_log.bind({self: self}), function(err, results) {
        callback(err, results);
    });
};

function parse_log(file, callback) {
    var IcecastLogParser = require('icecast-log-parser');
    var self = this.self;

    var targetDate = self.targetDate;
    var logName = self.logName;

    var sqlFile = file.path + "_sql";

    removeFileIfExist(sqlFile);

    log.info("Parse file: " + sqlFile);
    var sqlStream = fs.createWriteStream(sqlFile, {'flags': 'a'});

    var skippedCount = 0;
    var errorCount = 0;
    var reachCount = 0;
    var parser = new IcecastLogParser({name: logName});
    parser.on('entry', function(entry) {
        if (isSameDate(entry.date, targetDate)) {
            switch (logName) {
                case 'access.log':
                    if (writeAccessLogLineAsQuery(sqlStream, entry))
                        reachCount++;
                    else
                        skippedCount++;
                    break;
                case 'playlist.log':
                    if (writePlaylistLogLineAsQuery(sqlStream, entry))
                        reachCount++;
                    else
                        skippedCount++;
                    break;
            }
        } else {
            skippedCount++;
        }
    });

    parser.on('error', function(error) {
        errorCount++;
        log.warn("Parse " + sqlFile + " " + error.message);
        parser.resume(); // continue data processing after error is handled
    });

    parser.on('finish', function(){
        sqlStream.end();

        log.info("Skipped lines: " + skippedCount +
                 " Reach records: " + reachCount +
                 " Erorr count: " + errorCount +
                 " Total:" + (reachCount + skippedCount));

        var result = {
            path: sqlFile,
            skip: skippedCount,
            reach: reachCount,
            errors: errorCount,
            total: (reachCount + skippedCount)
        };

        callback(null, result);

        log.debug('File ' + sqlFile + ' parsing finished!');
    });

    var source = fs.createReadStream(file.path);
    source.pipe(parser);
}

function isSameDate(date, target) {
    return (moment(date).isSame(target, 'day'));
}

function getGeoBySypex(ip) {
    try {
        var result = {};

        var location = sypexGeoDb.find(ip);
        if (location) {
            //log.debug("(" + ip +") geo by sypex: " + JSON.stringify(location));

            result.country = location.country ? location.country.iso : null;
            result.city = location.city ? location.city.name.en : null;
            result.lat = location.latitude ? location.latitude : null;
            result.lon = location.longitude ? location.longitude : null;
        } else {
            return null;
        }

        if (!result.country)
            return null;

        return result;
    } catch(e) {
        log.error(e);
    }
    return null;
}

function getGeoByMaxMind(ip) {
    try {
        var result = {};

        var location = maxmind.getLocation(ip);

        if (location) {
            //log.debug("(" + ip +") geo by maxMind: " + JSON.stringify(location));

            result.country = location.countryCode ? location.countryCode : null;
            result.city = location.city ? location.city : null;
            result.lat = location.latitude ? location.latitude : null;
            result.lon = location.longitude ? location.longitude : null;
        } else {
            return null;
        }

        if (!result.country)
            return null;

        return result;
    } catch(e) {
        log.error(e);
    }
    return null;
}

function getGeoBy(ip) {
    var result = {};

    result = getGeoBySypex(ip);

    if (!result || !result.lat || !result.lon || !result.city)
        result = getGeoByMaxMind(ip);

    if (result) {
        if (!result.city || !result.country || !result.lat || !result.lon) {
            log.debug("(" + ip +") geo not complete: " + JSON.stringify(result));
        }
    } else {
        log.debug("(" + ip +") geo not found!");
    }

    return result;
}

function writeAccessLogLineAsQuery(sqlStream, entry) {
    if (entry.duration <= parser.skip_duration_less_seconds) return false; // не учитывать соединения длительность менее 4 секунд
    if (entry.duration >= parser.skip_duration_more_seconds) return false; // не учитывать соединения длительностью больше суток (86400 секунд)

    entry.mount = normalizeMount(entry.url);

    if (isIgnoredMount(entry.mount)) return false;

    var geo = getGeoBy(entry.ip);
    if (!geo) geo = {county: '', city: '', lat: null, lon: null};

    var dateStr = moment(entry.date).format('YYYY-MM-DD HH:mm:ss');
    var query = require('util').format("(%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %d, %d, %d, %s),\n",
                                        mysql.escape(entry.ip),
                                        mysql.escape(dateStr),
                                        mysql.escape(geo.country ? geo.country : ""),
                                        mysql.escape(geo.city ? geo.city : ""),
                                        geo.lat ? geo.lat.toFixed(6) : null,
                                        geo.lon ? geo.lon.toFixed(6) : null,
                                        mysql.escape(entry.method),
                                        mysql.escape(entry.mount),
                                        mysql.escape(entry.protocol),
                                        mysql.escape((!entry.referer) ? "" : entry.referer) ,
                                        entry.size,
                                        entry.duration,
                                        entry.status,
                                        mysql.escape((!entry.agent) ? "" : entry.agent)
                                      );
    sqlStream.write(query);

    return true;
}

function writePlaylistLogLineAsQuery(sqlStream, entry) {
    if (!(entry.meta)) return false;

    if (isIgnoredMount(entry.mount)) return false;

    var dateStr = moment(entry.date).format('YYYY-MM-DD HH:mm:ss');
    var query = require('util').format("(%s, %s, %d, %s, %s, %s),\n",
                                        mysql.escape(dateStr),
                                        mysql.escape(entry.mount),
                                        entry.count,
                                        mysql.escape(entry.meta),
                                        mysql.escape(entry.author),
                                        mysql.escape(entry.song_name)
                                      );
    sqlStream.write(query);

    return true;
}

function isIgnoredMount(mount) {
    if (!mount) return true;
    for (var i = 0; i < mounts_filter.length; i++) {
        var ignore = mounts_filter[i];
        if (mount.indexOf(ignore) > 0) return true;
        if (mount === "/") return true;
    }
    return false;
}

function normalizeMount(url) {
    var result = url;
    var arr = url.split('?');

    if (arr.length > 0)
        result = arr[0];

    arr = result.split('mount=');
    if (arr.length > 0)
        result = arr[0];

    if (result.lastIndexOf('/') > 0)
        result = result.substring(0, result.lastIndexOf('/'));

    return result;
}

IcecastToMySQL.prototype.insert_log_files_to_db = function(ftp, sqlFileList, callback) {
    var self = this;

    if (self.skip_insert) {
        log.info(ftp.host + ": skip insert log files to database by configuration option.");
        cb(null, {}); // skip insert
        return;
    }

    var con = mysql.createConnection({
        host: db.host,
        user: db.user,
        password: db.password,
        connectTimeout: db.timeout * 1000
    });

    var prefix = (self.logName == 'playlist.log') ? db.prefix_playlist : db.prefix_stations;
    var db_name = prefix + ftp.host;

    async.waterfall([
        function(cb) {
            con.connect(function(err, rows) { cb(err, rows); });
        },
        function(rows, cb) {
            con.query("SHOW DATABASES LIKE \'%" + db_name + "%\'", function(err, rows){ cb(err, rows); });
        },
        function(rows, cb) {
            if (rows.length === 0)
                con.query('CREATE DATABASE IF NOT EXISTS `' + db_name + '` DEFAULT CHARSET utf8 COLLATE utf8_general_ci', function(err, rows){ cb(err, rows); });
            else
                cb(null, {});
        },
        function(rows, cb) {
            con.query('use `' + db_name + '`', function(err,rows){ cb(err, rows); });
        },
        function(rows, cb) {
            con.query('DROP TABLE IF EXISTS `' + getTableName(self) +'`', function(err,rows){ cb(err, rows); });
        },
        function(rows, cb) {
            con.query(sql_create_table(self), function(err,rows){ cb(err, rows); });
        },
        function(rows, cb) {
            log.info("Sql files to be inserted: " + sqlFileList.length);
            async.map(sqlFileList, insert_log.bind({ftp:ftp, self: self, con: con, db_name: db_name}), function(err, results) {
                cb(err, results);
            });
        }
    ], function(err, results) {
        con.end(function(err) {
            if(err) log.error(err);
        });
        callback(err, results);
    });
};

function getTableName(self) {
    return moment(self.targetDate).format("YYYY-MM-DD");
}

function insert_log(sqlFile, callback) {
    var ftp = this.ftp;
    var self = this.self;
    var con = this.con;
    var db_name = this.db_name;

    if (sqlFile.reach > 0) {
        log.debug('insert for (' + sqlFile.path + ') to database!');

        var rowsInserted = 0;

        var LineByLineReader = require('line-by-line'),
            lr = new LineByLineReader(sqlFile.path),
            line_index = 0, linesCount = 0, sql = "", errorList = [];

        lr.on('error', function (err) {
            // 'err' contains error object
            log.error(err.message);
        });

        // 'line' contains the current line without the trailing newline character.
        lr.on('line', function (line) {
            sql += line.trim();
            line_index++; linesCount++;
            if (line_index >= parser.rows_batch_insert) {
                line_index = 0;
                lr.pause();
                send_insert(self, lr, con, sql, function(err, rows) {
                    if (err)
                        errorList.push({error: err, sql: sql});
                    else
                        rowsInserted += rows.affectedRows;
                });
                sql = "";
            }
        });

        // All lines are read, file is closed now.
        lr.on('end', function () {
            if (line_index > 0) {
                lr.pause();
                send_insert(self, lr, con, sql, function(err, rows){
                    if (err)
                        errorList.push({error: err, sql: sql});
                    else
                        rowsInserted += rows.affectedRows;

                    var result = {
                        sqlFile: sqlFile,
                        dbName: db_name,
                        tableName: getTableName(self),
                        rowsInserted: rowsInserted,
                        linesCount: linesCount,
                        errorList: errorList
                    };
                    callback(null, result);
                });
            } else {
                    var result = {
                        sqlFile: sqlFile,
                        dbName: db_name,
                        tableName: getTableName(self),
                        rowsInserted: rowsInserted,
                        linesCount: linesCount,
                        errorList: errorList
                    };
                    callback(null, result);
            }
        });

    } else {
        log.info(sqlFile.path + " doesn't reach any target by date record");
        callback(null, null);
    }
}

function send_insert(self, lr, con, sqlBody, cb) {
    var sqlHead = getSqlInsertHead(self);
    sqlBody = sqlBody.slice(0, -1); // remove "," at the end
    sql = sqlHead + sqlBody;
    con.query({ sql: sql, timeout: 5 * 60 * 1000 }, function(err, rows){
        cb(err, rows);
        lr.resume();
    });
}

function getSqlInsertHead(self) {
    var sql = "INSERT INTO `" + getTableName(self) + "`";
    switch (self.logName) {
        case 'access.log':
            return  sql + " (ip, date, country, city, lat, lon, method, mount, protocol, referer, sent_bytes, duration, status, agent) VALUES ";

        case 'playlist.log':
            return sql +  " (date, mount, count, meta, author, song_name) VALUES ";
    }
}

function sql_create_table(self) {
    switch (self.logName) {
        case 'access.log':
            return sql_get_access_log_table(self);
        case 'playlist.log':
            return sql_get_playlist_log_table(self);
    }
}

function sql_get_access_log_table(self) {
    return "CREATE TABLE `" + getTableName(self) + "` (" +
        "`id` INT(11) NOT NULL AUTO_INCREMENT," +
        "`ip` VARCHAR(20) NOT NULL," +
        "`date` DATETIME NOT NULL," +
        "`country` VARCHAR(4) NULL DEFAULT ''," +
        "`city` VARCHAR(512) NULL DEFAULT ''," +
        "`lat` DOUBLE DEFAULT NULL," +
        "`lon` DOUBLE DEFAULT NULL," +
        "`method` VARCHAR(10) NULL DEFAULT ''," +
        "`mount` VARCHAR(90) NOT NULL," +
        "`protocol` VARCHAR(20) NOT NULL," +
        "`referer` VARCHAR(400) NULL DEFAULT ''," +
        "`sent_bytes` INT(11) NULL DEFAULT -1," +
        "`duration` INT(11) NULL DEFAULT -1," +
        "`status` INT(11) NULL DEFAULT -1," +
        "`agent` VARCHAR(200) NULL DEFAULT ''," +
        "PRIMARY KEY (`id`)" +
    ") ENGINE=InnoDB DEFAULT CHARSET utf8 COLLATE utf8_general_ci;";
}

function sql_get_playlist_log_table(self) {
    return "CREATE TABLE `" + getTableName(self) + "` (" +
        "`id` INT(11) NOT NULL AUTO_INCREMENT," +
        "`date` DATETIME NOT NULL," +
        "`mount` VARCHAR(90) NOT NULL," +
        "`count` INT(11) NULL DEFAULT 0," +
        "`meta` VARCHAR(300) NULL DEFAULT ''," +
        "`author`    VARCHAR(300) NULL DEFAULT ''," +
        "`song_name` VARCHAR(300) NULL DEFAULT ''," +
        "PRIMARY KEY (`id`)" +
    ") ENGINE=InnoDB DEFAULT CHARSET utf8 COLLATE utf8_general_ci;";
}

// СТАРТОВАЯ ФУНКЦИЯ
IcecastToMySQL.prototype.run = function(callback) {
    var self = this;
    async.waterfall([
        function(cb) {
            self.read_ftp_configs_from_sql_table(function(err, ftpList) { cb(err, ftpList); });
        },
        function(ftpList, cb) {
            log.info("Process ftp list.");
            async.map(ftpList, self.process.bind({self: self}), function(err, results) { cb(err, results); } );
        }
    ], function(err, res) {
        log.info("End of run parse function.");
        res.error_messages = self.error_messages;
        callback(err, res);
    });
};

IcecastToMySQL.prototype.process = function(ftp, callback) {
    var self = this.self;
    // Оставить парсинг только для одного радио
    // if (ftp.host !== 'radio7server.streamr.ru/log') {
    //   callback(null, null);
    //   return;
    // }
    // console.log('ftp', ftp);
    async.waterfall([
        function(cb) {
            log.info(ftp.host + ": get remote file list.");
            self.get_remote_log_files_list(ftp, function(err, res) { cb(err, res); });
        },
        function(remoteFileList, cb) {
            if (remoteFileList.length === 0) {
                log.warn(ftp.host + ': remote file list is empty. Try later or tell administrator about that!');
                cb(null, []); // no remote files detected
            } else {
                log.info(ftp.host + ": download log files.");
                self.download_log_files(ftp, remoteFileList, function(err, res) { cb(err, res); });
            }
        },
        function(results, cb) {
            log.info(ftp.host + ": check download results.");
            if (results.length === 0) {
                log.warn(ftp.host + ': download file list is empty.');
                cb(null, []); // no download files detected
            } else {
                var failedDownloadList = [];
                var successDownloadList = [];
                for (var j = 0; j < results.length; j++) {
                    var result = results[j];
                    if (result.error) {
                        failedDownloadList.push(result);
                    } else {
                        successDownloadList.push(result);
                    }
                }

                if (failedDownloadList.length === 0) {
                    log.info(ftp.host + ": all logs was downloaded success.");
                    cb(null, successDownloadList);
                } else {
                    log.info(ftp.host + ": not all logs was downloaded -> so, redownload.");
                    var remoteFileList = [];
                    for (var i = 0; i < failedDownloadList.length; i++)
                        remoteFileList.push(failedDownloadList[i].remoteFile);

                    self.redownload_log_files(ftp, remoteFileList, function(err, results) {
                        var successList = [];
                        var failedList = [];

                        for (var i = 0; i < results.length; i++) {
                            var result = results[i];
                            if (!result.error) {
                                successDownloadList.push(result);
                            }
                        }
                        cb(null, successDownloadList);
                    });
                }
            }
        },
        function(successDownloadList, cb) {
            log.info(ftp.host + ": parse log files.");
            if (successDownloadList.length === 0) {
                log.warn(ftp.host + ': success download file list is empty.');
                cb(null, []); // no downloaded files detected
            } else {
                self.parse_log_files(ftp, successDownloadList, function(err, results) { cb(err, results); });
            }
        },
        function(sqlParsedList, cb) {
            if (self.skip_insert) {
                log.info(ftp.host + ": skip insert log files to database by configuration option.");
                cb(null, []); // skip insert
            } else {
                log.info(ftp.host + ": insert log files to database.");
                if (sqlParsedList.length === 0) {
                    log.info(ftp.host + ': parsed sql file list is empty.');
                    cb(null, []); // no parsed files detected
                } else {
                    self.insert_log_files_to_db(ftp, sqlParsedList, function(err, results) { cb(err, results); });
                }
            }
        }
    ], function(err, results) {
        log.info(ftp.host + ": end of parsing. Return results.");
        callback(err, {ftp: ftp, items: results});
    });
};

IcecastToMySQL.prototype.freeLogStream = function() {
    if (this.log_stream) {
        this.log_stream.end();
        this.log_stream = null;
    }
};

